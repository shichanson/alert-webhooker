// Code generated by MockGen. DO NOT EDIT.
// Source: runner.go

// Package runner is a generated GoMock package.
package runner

import (
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
	time "time"
)

// Mockblocker is a mock of blocker interface
type Mockblocker struct {
	ctrl     *gomock.Controller
	recorder *MockblockerMockRecorder
}

// MockblockerMockRecorder is the mock recorder for Mockblocker
type MockblockerMockRecorder struct {
	mock *Mockblocker
}

// NewMockblocker creates a new mock instance
func NewMockblocker(ctrl *gomock.Controller) *Mockblocker {
	mock := &Mockblocker{ctrl: ctrl}
	mock.recorder = &MockblockerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *Mockblocker) EXPECT() *MockblockerMockRecorder {
	return m.recorder
}

// BlockInProgress mocks base method
func (m *Mockblocker) BlockInProgress(executor, fingerprint string) (bool, error) {
	ret := m.ctrl.Call(m, "BlockInProgress", executor, fingerprint)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BlockInProgress indicates an expected call of BlockInProgress
func (mr *MockblockerMockRecorder) BlockInProgress(executor, fingerprint interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BlockInProgress", reflect.TypeOf((*Mockblocker)(nil).BlockInProgress), executor, fingerprint)
}

// BlockForTTL mocks base method
func (m *Mockblocker) BlockForTTL(executor, fingerprint string, ttl time.Duration) error {
	ret := m.ctrl.Call(m, "BlockForTTL", executor, fingerprint, ttl)
	ret0, _ := ret[0].(error)
	return ret0
}

// BlockForTTL indicates an expected call of BlockForTTL
func (mr *MockblockerMockRecorder) BlockForTTL(executor, fingerprint, ttl interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BlockForTTL", reflect.TypeOf((*Mockblocker)(nil).BlockForTTL), executor, fingerprint, ttl)
}

// Unblock mocks base method
func (m *Mockblocker) Unblock(executor, fingerprint string) {
	m.ctrl.Call(m, "Unblock", executor, fingerprint)
}

// Unblock indicates an expected call of Unblock
func (mr *MockblockerMockRecorder) Unblock(executor, fingerprint interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unblock", reflect.TypeOf((*Mockblocker)(nil).Unblock), executor, fingerprint)
}

// Mockmetricser is a mock of metricser interface
type Mockmetricser struct {
	ctrl     *gomock.Controller
	recorder *MockmetricserMockRecorder
}

// MockmetricserMockRecorder is the mock recorder for Mockmetricser
type MockmetricserMockRecorder struct {
	mock *Mockmetricser
}

// NewMockmetricser creates a new mock instance
func NewMockmetricser(ctrl *gomock.Controller) *Mockmetricser {
	mock := &Mockmetricser{ctrl: ctrl}
	mock.recorder = &MockmetricserMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *Mockmetricser) EXPECT() *MockmetricserMockRecorder {
	return m.recorder
}

// ExecutedTaskObserve mocks base method
func (m *Mockmetricser) ExecutedTaskObserve(rule, alert, executor, result string, err error, duration time.Duration) {
	m.ctrl.Call(m, "ExecutedTaskObserve", rule, alert, executor, result, err, duration)
}

// ExecutedTaskObserve indicates an expected call of ExecutedTaskObserve
func (mr *MockmetricserMockRecorder) ExecutedTaskObserve(rule, alert, executor, result, err, duration interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecutedTaskObserve", reflect.TypeOf((*Mockmetricser)(nil).ExecutedTaskObserve), rule, alert, executor, result, err, duration)
}
